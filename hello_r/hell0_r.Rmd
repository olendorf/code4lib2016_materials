---
title: "Hello R"
author: "Robert Olendorf"
date: "February 16, 2016"
output: html_document
---

## Hello R

Type ```1 + 1``` into the console and hit return. You should see the answer. 


```{r}
# This is a comment, and as simple as it gets.
1 + 1
```

Setting a variable. Notice I enter the **_a_** again to print it. Otherwise it would only display the assignment without a result. R is dynamically typed, so it makes an assumption about what you want.

```{r}
  # An integer
  a.int <- 1
  a.int
  
  # A float
  a.float <- 1.1
  a.float
  
  # A character
  a.char <- "b"
  a.char
  
  # If I want to have the character one, I have to quote it.
  a.char.2 <- "1"
  a.char.2
  # Im using a built in function here.
  is.numeric(a.char.2)
  
  # Logical
  a.logical <- TRUE
  a.logical
  
```

Identifiers consist of a sequence of letters, digits, the period (‘.’) and the underscore. They must not start with a digit or an underscore, or with a period followed by a digit. Periods are more often used than underscores in R. They don't have a special meaning, but are often used to unofficially namespace things 

```{r}
  # This works
  ab1.my.things = 3
  ab1.my.things
  
  # This doesn't
  "1.my.things = 4"
```

## Data Structures

R has a few data structures too. 

### Vectors

Vectors are essentially an array. They all have to be the same data type.

```{r}
  vect.1 <- c(1,2,3,4)  # numeric vector
  vect.1
  
  vect.2 <- c("one", "2", "three") # character vector
  vect.2
  
  vect.3 <- c(1, "2", 3) # R forces this to all characters
  vect.3
  
  vect.4 <- c(TRUE, FALSE, TRUE, FALSE) #logical vector
  vect.4
```

You can also create vectors quickly using the following syntaxes.

```{r}
  vect.5 <- 0:5
  vect.5
  
  
  vect.6 <- seq(0, 5, 0.5)
  vect.6
```

Access parts of an array like this. 

```{r}
  vect.5[1]  # Notice that unlike many programming languages indexs in R start with one
  vect.5[0]  # Returns somethign funny
  vect.5[c(1, 4)] # Returns the first and fourth elements
  vect.5[2:4]  # Returns second through fourth elements (slice)
```

```{r}
  
  ## You can also do some cool things like this.
  vect.bool = c(TRUE, FALSE, FALSE, TRUE, FALSE, TRUE)
  vect.5[vect.bool]
```

### Matrices
Matrices are really are always 2 dimensional. They work similar to vectors but have some interesting properties and gotchas.

```{r}
  #  Generate a matrix.
  matrx.1 <- matrix(1:20, nrow=5, ncol=4)
  matrx.1
  
  # By default R fills down a column, but you can fill across rows too
  matrx.row <- matrix(1:20, nrow = 5, ncol = 4, byrow = TRUE)
  matrx.row
  
  # You can also incompletely fill a matrix. R will just repeat the series until the 
  # matrix is full.
  matrx.incomplete <- matrix(1:10, nrow = 5, ncol = 4)
  matrx.incomplete
```

Accessing parts of matrices follows is pretty easy.

```{r}
  matrx.1[,4]  # Gets the fourth column
  matrx.1[3,]  # Gets the third row
  matrx.1[3,4] # Gets the entry in the fourth column and third row
  matrx.1[2:4, 1:3] # Rows 2 through 4 and columns 1 through 3
```

You can do Arrays too. They function pretty much like multidimensional matrices.

### Lists
You might feel like a vector is to restrictive. Your right! So R has lists as well. They are an ordered collection of objects. The object can be pretty much any other data type, and they don't all have to be the same.

```{r}
  # This is how we make a list. Notice were mixing in a string, vector, matrix 
  # and float, and also referencing other variables.
  my.list <- list(char = "foo", vect = vect.1, matrx = matrx.1, flt = 1.1)
  my.list
  
  my.list[[2]] # Accessing a list item by the index
  my.list[["char"]] # accessing a list item by name
```

### Data Frames

This is perhaps the most confusing part of R. Its sort of like a matrix, but the colums can be different datatypes. It is usually what you will use if you are reading in tabular data from CSV files or querying a database. Its similar to datasets in other statistical languages. I think of Data Frames as a list of vectors, but all the vectors need to be the same length.

```{r}
  var1 <- c("one", "two", "foo", "man", "choo")
  var2 <- 1:5
  var3 <- c(TRUE, FALSE, TRUE, FALSE, TRUE)
  var4 <- c("red", "blue", "orange", "blue", "red")
  var5 <- c(1,2,3,4,5)
  
  my.data = data.frame(var1, var2, var3, var4, var5)
  
  names(my.data) <- c("ID", "count", "result", "color", "number") # rename the columns
  
```

You can access parts of your data similar to lists.

```{r}
  my.data[3:5]  # gets columns 3-5
  my.data[c(1,3)] # gets columns 1 and 3
  my.data[c("ID", "color")]  # gets columns by name
  my.data$result  # gets variable by name
```

### Factors

Sometimes you want to tell R that a variable is **categorical**. R calls these factors.

```{r}
  ## Make some count data
  flower.color <- c(rep("red", 20), rep("blue", 28), rep("purple", 18))
  flower.color

  summary(flower.color)  # Summary won't work so well 
  
  # Define the colors as factors
  flower.color <- factor(flower.color)
  flower.color
  
  summary(flower.color)  # Now Summary works
```









